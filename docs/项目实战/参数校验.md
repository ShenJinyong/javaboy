# 参数校验



在当前前后端分离的模式下，接口的安全性显得格外的重要。

大多数时候，很痛苦遇到大量的参数进行校验,在业务中还要抛出异常或者不断的返回异常时的校验信息,在代码中相当冗长, 充满了if-else这种校验代码，于是`Spring`的`javax.validation` 注解式参数校验。

## 请求方法

对于接口，不外乎增删改查！

| 行为 | 原本请求方式 | 注解             | 最佳实践   |
| ---- | ------------ | ---------------- | ---------- |
| 新增 | `Post`       | `@PostMapping`   | Post请求   |
| 删除 | `Delete`     | `@DeleteMapping` | Delete请求 |
| 修改 | `Put`        | `@PutMapping`    | Post请求   |
| 查询 | `Get`        | `@GetMapping`    | Get请求    |

补充：`patch`请求，注解`@PatchMapping`,目的是**对资源数据打补丁或局部更新**。

## 参数封装

### Post

对于新增和修改行为，通常采用Post请求，一般情况下都会采用`json`的格式进行传递参数，于是需要进行参数的封装，将参数封装成同一个xxxDTO类。

举个栗子：

```java
@ApiOperation(value = "新增纠纷")
@PostMapping("/addDisputes")
public ResponseEntity addDisputes(@Validated @RequestBody DisputesDTO disputesDTO){
	return null;
}

@ApiOperation(value = "修改纠纷")
@PostMapping("/updateDisputes")
public ResponseEntity updateDisputes(@Validated @RequestBody DisputesDTO disputesDTO){
	return null;
}
```

注意:

- `@Validated`注解必须添加,校验才会生效

- 在xxxDTO里面设置参数的校验规则

但是又有一个新的问题，新增和修改的时候参数就会不一致，这时候就需要使用分组校验。

> 第一步：定义xxxDTO分组校验规则

比如:对于`id`,更新的时候不能为空;对于`name`,创建和更新的时候不能为空!

```java
@NotBlank(message="id不能为空！",groups = {Update.class})
private String id;

@NotBlank(message="name不能为空！",groups = {Create.class,Update.class})
private String name;
```

> 第二步:使用xxxDTO分组校验规则

比如:新增纠纷使用`Create.class`校验规则,修改纠纷使用`Update.class`校验规则

```java
@ApiOperation(value = "新增纠纷")
@PostMapping("/addDisputes")
public ResponseEntity addDisputes(@Validated({Create.class}) @RequestBody DisputesDTO disputesDTO){

}

@ApiOperation(value = "修改纠纷")
@PostMapping("/updateDisputes")
public ResponseEntity updateDisputes(@Validated({Update.class}) @RequestBody DisputesDTO disputesDTO){

}
```

### Get和Delete

对于查询和删除的行为,不太适合进行封装,原因:

- 请求的参数数量较少
- 请求的实体类是虚拟概念

通常情况下,都是采用表单提交,格式`application/x-www-form-urlencoded`。

校验的时候,直接在请求参数上使用`@P`进行校验,比如:

```java
@ApiOperation(value = "查询纠纷")
@PostMapping("/queryDisputes")
public ResponseEntity<List<DisputesDTO>> queryDisputes(
    @RequestParam(value = "key",required = false)String key,         
    @RequestParam(value = "current_page", required = false, defaultValue = "1") Integer currentPage,
    @RequestParam(value = "page_size", required = false, defaultValue = "10") Integer pageSize,){
    return null;
}

```

说明:

- value对应请求参数
- required,请求参数是否必填,默认为true
- defaultValue,默认值

## Validator

### 概述

`JSR303` 定义了 `Bean Validation`（校验）的标准 `validation-api`，但并没有提供实现。`Hibernate Validation`是对这个规范的实现 ，并且增加了 `@Email`、`@Length`、`@Range` 等注解。`Spring Validation` 底层依赖的就是`Hibernate Validation`。

- **JSR303**：JSR303是一项标准，只提供规范不提供实现。定义了校验规范即校验注解如：@Null、@NotNull、@Pattern。位于：`javax.validation.constraints`包下。
- **hibernate validation**：是对 JSR303 规范的实现并且进行了增强和扩展。并增加了注解：@Email、@Length、@Range等。
- **spring Validation**：是对Hibernate Validation的二次封装。在SpringMvc模块中添加了自动校验。并将校验信息封装到特定的类中。

### 约束

**JSR 提供的校验注解：**

- `@Null` 被注释的元素必须为 null
- `@NotNull` 被注释的元素必须不为 null
- `@AssertTrue` 被注释的元素必须为 true
- `@AssertFalse` 被注释的元素必须为 false
- `@Min(value)` 被注释的元素必须是一个数字，其值必须大于等于指定的最小值
- `@Max(value)` 被注释的元素必须是一个数字，其值必须小于等于指定的最大值
- `@DecimalMin(value)` 被注释的元素必须是一个数字，其值必须大于等于指定的最小值
- `@DecimalMax(value)` 被注释的元素必须是一个数字，其值必须小于等于指定的最大值
- `@Size(max=, min=)` 被注释的元素的大小必须在指定的范围内
- `@Digits (integer, fraction)` 被注释的元素必须是一个数字，其值必须在可接受的范围内
- `@Past` 被注释的元素必须是一个过去的日期
- `@Future` 被注释的元素必须是一个将来的日期
- `@Pattern(regex=,flag=)` 被注释的元素必须符合指定的正则表达式

**Hibernate Validator提供的校验注解：**

- `@NotBlank(message =)` 验证字符串非 null，且长度必须大于 0
- `@Email` 被注释的元素必须是电子邮箱地址
- `@Length(min=,max=)` 被注释的字符串的大小必须在指定的范围内
- `@NotEmpty` 被注释的字符串的必须非空
- `@Range(min=,max=,message=)` 被注释的元素必须在合适的范围内

### 依赖

- SpringBoot提供了validator启动器

```java
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

- 非SpringBoot项目，需要自行引入依赖

```java
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>6.1.5.Final</version>
</dependency>
<dependency>
    <groupId>org.glassfish</groupId>
    <artifactId>jakarta.el</artifactId>
    <version>3.0.3</version>
</dependency> 
```

### 例子

```java
@Data
public class Student {
    
    @NotBlank(message = "用户名不能为空")
    private String name;
    
    @Min(value = 18, message = "年龄不能小于18岁")
    private Integer age;
    
    @Pattern(regexp = "^((13[0-9])|(14[5,7,9])|(15([0-3]|[5-9]))|(166)|(17[0,1,3,5,6,7,8])|(18[0-9])|(19[8|9]))\\d{8}$", message = "手机号格式错误")
    private String phone;
    
    @Email(message = "邮箱格式错误")
    private String email;
    
    @Valid
    @NotNull
    private School school;

    @Data
    private static class School{
        @NotBlank(message = "学校名不能为空")
        private String name;
        @NotBlank(message = "学校地址不能为空")
        private String address;
    }
}
```

## 推荐

推荐文章:

- [SpringBoot参数校验-Validator - 你在谁的风景里a - 博客园 (cnblogs.com)](https://www.cnblogs.com/sanye613/p/15027448.html)
