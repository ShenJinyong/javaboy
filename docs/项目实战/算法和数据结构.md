# 算法和数据结构

> 题目一

认识时间复杂度

常数时间的操作

一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。

时间复杂度为一个算法流程中，常数操作数量的一个指标。常用O(读作bigO)来表示。具体来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作，进而总结出常数操作数量的表达式。

在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那么时间复杂度为O(f(N))。

评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。

> 题目二

选择排序、冒泡排序细节的讲解与复杂度分析

时间复杂度O(N^2)，额外空间复杂度O(1)

> 题目三

插入排序细节的讲解与复杂度分析

时间复杂度O(N^2)，额外空间复杂度O(1)

算法流程按照最差情况来估计时间复杂度

> 题目四

二分法的详解与扩展

1）在一个有序数组中，找某个数是否存在

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型一维数组 
     * @param target int整型 
     * @return int整型
     */
    public int search (int[] nums, int target) {
        // write code here
        return binarySearch(nums,target,0,nums.length-1);
    }

    public int binarySearch(int[] nums,int target,int left,int right){
        if(left > right){
            return -1;
        }
        int mid = (left + right)/2;
        if(target > nums[mid]){
            return binarySearch(nums,target,mid+1,right);
        }else if(target < nums[mid]){
            return binarySearch(nums,target,left,mid-1);
        }else{
            return mid;
        }
    }

}
```

2）在一个有序数组中，找>=某个数最左侧的位置

3）局部最小值问题

```java
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        // return sequentialSearch(array);
        return binarySearch(array,0,array.length-1);
    }

    // 二分查找，局部最小
    public int binarySearch(int [] array,int left,int right){
        // 数组为空
        if(array == null || array.length == 0){
            return -1;
        }
        int count = right - left;
        // 数组只剩一个
        if(count == 0){
            return array[left];
        }
        // 数组只剩二个
        if(count == 1){
            if(array[left] >= array[right]){
                return array[right];
            }else{
                return array[left];
            }
        }
        // 不旋转
        if(array[left] < array[right]){
            return array[left];
        }
        // 旋转
        int mid = (left+right)/2;
        // 特殊情况：如果无法确定中间元素是属于前面还是后面的递增子数组，只能顺序查找
        if(array[left] == array[right] && array[left] == array[mid]){
            return sequentialSearch(array,left+1,right-1);
        }
         // 中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面
        if(array[mid] >= array[left]){
            return binarySearch(array,mid+1,right);
        }else{
            // 中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面
            return binarySearch(array,left,right-1);
        }
    }

    // 顺序查找
    public int sequentialSearch(int [] array,int left,int right){
        int min = array[left];
        for(;left <= right;left++){
            if(min > array[left]){
                min = array[left];
            }
        }
        return min;
    }

}
```

> 题目五

异或运算的性质与扩展

1）0^N==NN^N==0

2）异或运算满足交换律和结合率

3）不用额外变量交换两个数

4）一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数

5）一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数

> 题目六

对数器的概念和使用

1，有一个你想要测的方法a

2，实现复杂度不好但是容易实现的方法b

3，实现一个随机样本产生器

4，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。

5，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者方法b

6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。

> 题目七

剖析递归行为和递归行为时间复杂度的估算

用递归方法找一个数组中的最大值，系统上到底是怎么做的？

master公式的使用

`T(N) = a*T(N/b)+O(N^d)*`

1)log(b,a)>d	===>	复杂度为O(N^log(b,a))

2)log(b,a)=d	===>	复杂度为O(N^d*logN)

3)log(b,a)<d	===>	复杂度为O(N^d)

> 补充阅读

[算法的复杂度与 Master 定理 · GoCalf Blog](https://blog.gocalf.com/algorithm-complexity-and-master-theorem)