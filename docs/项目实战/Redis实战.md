# Redis实战

## 缓存

### 什么是缓存

缓存就是数据交换的缓冲区（称作Cache），是存储数据的临时地方，一般读写性能较高。

缓存可以解决CPU与内存之间读取速率之间的问题。

寄存器、高速缓存、缓存、硬盘

缓存的作用：

- 降低后端负载
- 提高读写效率，降低响应时间

缓存的成本：

- 数据一致性成本
- 代码维护成本

### 添加Redis缓存

```java
@Override
public Object queryById(Long id) {
    // 1.从Redis查询商铺缓存
    String shopJson = stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id);
    // 2.判断是否存在
    if(StrUtil.isNotBlank(shopJson)){
        // 3.存在，直接返回
        Shop shop = JSONUtil.toBean(shopJson, Shop.class);
        return Result.ok(shop);
    }
    // 4.不存在，根据id查询数据库
    Shop shop = getById(id);
    // 5.不存在，返回错误
    if(shop == null){
        return Result.fail("店铺不存在!");
    }
    // 6.存在，写入redis
    stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id,JSONUtil.toJsonStr(shop));
    // 7.返回
    return Result.ok(shop);
}
```

### 缓存更新策略

| 机制     | 内存淘汰                                                     | 超时剔除                                                     | 主动更新                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------- |
| 说明     | 不用自己维护，利用Redis的内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存。 | 会给缓存数据添加TTL,到期后自动删除缓存。下次查询时更新缓存。 | 编写业务逻辑，在修改数据库的同时，更新缓存。 |
| 一致性   | 差                                                           | 一般                                                         | 好                                           |
| 维护成本 | 无                                                           | 低                                                           | 高                                           |

业务场景：

- 低一致性需求：使用内存淘汰机制。例如店铺类型的查询缓存
- 高一致性需求：主动更新，并以超时剔除作为兜底方案。例如店铺详情查询的缓存。

> 主动更新策略

- Cache Aside Pattern由缓存的调用者，在更新数据库的同时更新缓存
- Read/Write Through Pattern缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无序关心一致性问题。
- Write Behind Caching Pattern调用者只操作缓存，由其他线程异步的将缓存数据持久化到数据库，保证最终一致性

说明：方案2是强一致性，3是最终一致性，方案1是企业常用的

> 操作缓存和数据库时有三个问题需要考虑

- 删除缓存还是更新缓存
  - 更新缓存：每次更新数据库都更新缓存，无效写操作较多
  - 删除缓存：更新数据库时让缓存失效，查询时再更新缓存【使用】
- 如何保证缓存与数据库的操作的同时成功或失败
  - 单体系统，将缓存与数据库操作放在一个事务
  - 分布式系统，利用TCC等分布式事务方案
- 先操作缓存还是先操作数据库
  - 先删除缓存，再操作数据库【优先】
  - 先操作数据库，再删除缓存

> 总结

缓存更新策略的最佳实践方案：

- 低一致性需求：使用Redis自带的内存淘汰机制
- 高一致性需求：主动更新，并以超时剔除作为兜底方案
  - 读操作
    - 缓存命中则直接返回
    - 缓存未命中则查询数据库，并写入缓存，设定超时实践
  - 写操作
    - 先写数据库库，然后再删除缓存
    - 要确保数据库与缓存操作的原子性

spring事务时基于aop实现的，控制的是方法，和数据库的事务不同~

用rabbitmq，每次增删改了数据库发一条消息，消费者拿到消息更新下redis就好。

### 缓存穿透

缓存穿透是指客户端请求的数据再缓存中和数据库中都不存在，这样缓存永久不会生效，这些请求打到数据库。

解决缓存传统的方法：

- 缓存空值
  - 优点：实现简单，维护方便
  - 缺点：
    - 有额外的内存消耗
    - 可能造成短期的不一致性，设置TTL时间短
- 布隆过滤器
  - 优点：内存占用较少，没有多余key
  - 缺点：
    - 实现复杂
    - 存在误判的可能

缓存穿透产生的原因是什么？

用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求给数据库带来巨大的压力

缓存穿透的剞劂方案有哪些？

- 缓存null值
- 布隆过滤
- 增加id的复杂度，避免被猜测id规律
- 做好数据基础格式校验
- 加强用户权限校验
- 做好热点参数的限流

### 缓存雪崩

缓存雪崩是指在同一时段的缓存key同时失效或者Redis服务宕机，导致大量的请求到达服务器，带来巨大压力。

解决方案：

- 给不同的key的TTL添加随机值
- 利用Redis集群服务的可用性
- 给缓存业务添加降级限流策略
- 给业务添加多级缓存

### 缓存击穿

缓存击穿问题也叫热点问题，就是一个被高并发访问并且缓存重建业务比较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。

常见的解决方案有两种：

- 互斥锁
- 逻辑过期

| 解决方案 | 优点                                     | 缺点                                     |
| -------- | ---------------------------------------- | ---------------------------------------- |
| 互斥锁   | 没有额外的内存消耗；保证一致性；实现简单 | 线程需要等待，性能受影响；可能有死锁风险 |
| 逻辑过期 | 线程无需等待，性能较好                   | 不保证一致性；有额外的内存消耗；实现复杂 |

### 缓存工具封装

基于StringRedisTemplate封装一个缓存工具类，满足下列需求：

- 方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间
- 方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用户处理缓存击穿问题
- 方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题
- 方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题

## 优惠卷秒杀

### 全局唯一ID

> 全局ID生产器

每个店铺都可以发布优惠卷,当用户抢购时，就会生成订单并保存到tb_voucher_order这张表，而订单表如果使用数据库自增ID就存在一些问题：

- id的规律性太明显
- 受单表数据量的限制

全局ID生产器，时一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：

- 唯一性
- 高可用
- 高性能
- 递增性
- 安全性

为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其他信息。

ID的组成部分：

- 符号位：1bit，永远为0
- 时间戳（31 bit），以秒杀为单位，可以使用69年
- 序列号（32 bit），秒内的计数器，支持每秒产生2的32次方个不同ID

全局唯一ID生成策略：

- UUID
- Redis自增
- snowflake算法
- 数据库自增

Redis自增ID策略：

- 每天一个key，方便统计订单量
- ID构造是：时间戳+计数器



### 实现优惠卷秒杀下下单

### 超卖问题

### 一人一单

### 分布式锁

### Redis优化秒杀

### Redis消息队列实现异步秒杀