# 基本概念

## 基本概念

> 常数时间的操作

一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。

> 认识时间复杂度

时间复杂度为一个算法流程中，常数操作数量的一个指标。常用O(读作bigO)来表示。具体来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作，进而总结出常数操作数量的表达式。

在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那么时间复杂度为O(f(N))。

> 算法好坏

评价一个算法流程的好坏，先看时间复杂度的指标【算法流程按照最差情况来估计时间复杂度】，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。

> 对数器的概念和使用

1. 有一个你想要测的方法a

2. 实现复杂度不好但是容易实现的方法b

3. 实现一个随机样本产生器
4. 把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。
5. 如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者方法b
6. 当样本数量很多时比对测试依然正确，可以确定方法a已经正确。

> 异或运算的性质与扩展

1. 0^N==N	N^N==0
2. 异或运算满足交换律和结合率
3. 不用额外变量交换两个数
4. 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数
5. 一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数

> 剖析递归行为和递归行为时间复杂度的估算

剖析递归行为和递归行为时间复杂度的估算,用递归方法找一个数组中的最大值，系统上到底是怎么做的？

master公式的使用：

`T(N) = a*T(N/b)+O(N^d)*`

1. log(b,a)>d	===>	复杂度为O(N^log(b,a))
2. log(b,a)=d	===>	复杂度为O(N^d*logN)
3. log(b,a)<d	===>	复杂度为O(N^d)

> 二分法的详解与扩展

1. 在一个有序数组中，找某个数是否存在

2. 在一个有序数组中，找>=某个数最左侧的位置

3. 局部最小值问题

> 堆

1. 堆结构就是用数组实现的完全二叉树结构
2. 完全二叉树中如果每棵子树的最大值都在顶部就是大根堆
3. 完全二叉树中如果每棵子树的最小值都在顶部就是小根堆
4. 堆结构的heapInsert与heapify操作
5. 堆结构的增大和减少
6. 优先级队列结构，就是堆结构

> 比较器的使用

1. 比较器的实质就是重载比较运算符
2. 比较器可以很好的应用在特殊标准的排序上
3. 比较器可以很好的应用在根据特殊标准排序的结构上

## 参考文章

1. [算法的复杂度与 Master 定理](https://blog.gocalf.com/algorithm-complexity-and-master-theorem)

