# 设计模式

> 设计模式包含pdf版本，需要将后缀修改为pdf
>
> 举个栗子：
>
> - 修改前：`http://localhost:5173/javaboy/设计模式/设计模式.html`
> - 修改后：`http://localhost:5173/javaboy/设计模式/设计模式.pdf`

## 前言

**Hello，world of design！**您好，设计模式的世界！

欢迎来到这里，很高兴您能拿到这本书。如果您能坚持看完并按照书中的栗子进行实践，那么在编程开发的世界里，就又多了一个可以写出良好代码的人，同时也为架构师培养储备了一个人才。

可能在此之前，您或多或少的了解过设计模式，但是在实际的业务开发中使用过一种或者多种设计模式，但是您并不知道使用的是哪种设计模式，或者说不知道项目中所使用的技术其底层实现的设计模式是哪种设计模式，大多数的时候都是大面积堆积`ifelse`组装业务流程，对于一次次的需求迭代和逻辑补充，只能东拼西凑`Ctrl+C`、`Ctrl+V`。但是，这时候往往我们对原理的了解并不是很多，在需要涉及原理上去解决问题的时候，往往是搞得焦头烂额。

所以为了让更多的程序猿👨‍💻，更好的接受设计思想和架构思维，并能运用到实际的业务场景。在重学Java设计模式的基础之上，加上作者本身的思考，从互联网实际业务开发中抽离出多个真实场景，来学习并实践设计模式，使之成为大家的可上手技能。

**谁发明了设计模式？**

设计模式的概念最早是由`克里斯托佛·亚历山大`在其著作**《建筑模式语言》**中首次提出的。本书介绍了城市设计的“语言”，提供了253哥个描述城镇、邻里、住宅、花园、房间及西部构造的模式，而此类“语言”的基础单元就是模式。后来，`埃里希·伽玛`、`约翰·弗离赛德斯`、`拉尔夫·约翰逊`和`理查德·赫尔姆`这四位作者接受了模式的概念。1994年，他们出版了《**设计模式：可复用面向对象软件的基础》**一书，将设计模式的概念应用到程序开发领域中。

其实由一部分人并没有仔细阅读过设计模式的相关书籍和资料，但依旧可以编写出优秀的代码。这主要是由于在经过众多项目的锤炼和对程序设计的不断追求，从而在多年编程历程上提炼出来的心得体会。然而这份经验最终会与设计模式提到的内容几乎一致，同样会要求高内聚、低耦合、可扩展和可复用。当然，您可能会遇到类似的经历，在学习一些框架的源码时，发现它的某些设计和您在做开发时是一致的。

**我怎么学不会设计模式？**

钱也花了，书页买了。代码还是一坨一坨的！设计模式是由多年的经验提炼出来的开发指导思想。就好比我告诉您自行车怎么骑和汽车怎么开，但是只要您没跑过几千公里，您能记住的只是理论，想上道依旧很慌！实践才是检验真理的唯一标准。

所以，设计模式专题系列从开始，会带着您使用设计模式的思想去优化代码。在此过程中，感悟学习设计模式的心得并融会贯通，在以后的编程上，才能运用自如。当然这里害需要多家联系，一定是人车合一，才能站在设计模式的基础上构建出更加合理的代码。当然，在实践过程中，不要为了使用设计模式而去用设计模式，这样会徒添很多烦恼。

**阅读建议**

本书属于实战型而不是理论介绍书籍，每一章节都有相应的完整代码，学习过程中需要参考书中的章节与代码一起学习，同时在学习的过程中需要了解并运行代码。学习完成后进行知识点的总结和思考🤔，这样的设计模式在自己的业务场景中需要如何使用。

**参考资料**

本书在编写过程中参考了非常优秀的理论自立哦啊，读者在学习的过程中也可以相互参考借鉴。

## 特点

| 目的 | 创建型模式Creational Pattern                                 | 结构型模式Structural Patterns                                | 行为型模式Behavioral Pattern                                 |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 概念 | 创建型模式就是创建对象的模式，抽象了实例化的过程。他帮助一个系统独立于如何创建、组合和表示他的那些对象。关注的是对象的创建，创建型模式讲创建对象的过程进行了抽象，也可以理解为将创建对象的过程进行了封装，作为客户程序仅仅需要去使用对象，而不再关心创建对象过程种的逻辑。 | 结构型模式是为解决怎样组装现有的类，设计他们的交互方式，从而达到实现一定的功能的目的。结构型模式包容了对外很多问题的解决。例如：扩展性（外观、组成、代理、装饰），封装性（适配器、桥接）。 | 行为型模式涉及到算法和对象间的职责分配，行为模式描述了对象和类的模式，以及它们之间的通信模式，行为型模式刻划了在程序运行时难以跟踪的复杂的控制流可分为行为类模式和行为对象模式。行为模式使用继承机制在类间分派行为；行为对象模式使用对象聚合来分配行为。一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任何一个对象都无法单独完成的任务。 |
| 类   | Factory Method                                               | Adapter(类)                                                  | Interpreter                                                  |
|      |                                                              |                                                              | Template Method                                              |
| 对象 | Abstract Factory                                             | Adapter(对象)                                                | Chain of Responsibility                                      |
|      | Builder                                                      | Bridge                                                       | Command                                                      |
|      | Prototype                                                    | Composite                                                    | Iterator                                                     |
|      | Singleton                                                    | Decorator                                                    | Mediator                                                     |
|      |                                                              | Facade                                                       | Memento                                                      |
|      |                                                              | Flyweight                                                    | Observer                                                     |
|      |                                                              | Proxy                                                        | State                                                        |
|      |                                                              |                                                              | Strategy                                                     |
|      |                                                              |                                                              | Visitor                                                      |

## 六大原则

设计模式遵循六大原则：

- 单一职责（**一个类和方法只做一件事**）
- 里氏替换（**多态，子类可扩展父类**）
- 依赖倒置（**细节依赖抽象，下层依赖上层**）
- 接口隔离（**建立单一接口**）
- 迪米特原则（**最少知道，降低耦合**）
- 开闭原则（**抽象架构，扩展实现**）

### 开放封闭原则

Open-Close Principle(OCP):一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。目的就是保证程序的扩展性，易于维护和升级。

开闭原则被称为面向对象设计的基石，实际上，其他原则都可以看作是实现开闭原则的工具和手段。意思就是说：软件对扩展应该是开放的，对修改时关闭的。通俗来讲就是，开发一个软件时，应该对其进行功能扩展，而在进行这些扩展时，不需要对原来的程序进行修改。

好处：软件可用性非常灵活，扩展性强。需要新的功能时，可以增加新的模块来满足新的需求，另外由于原来的模块没有修改，所以不用担心稳定性的问题。

### 单一职责原则

Single-Responsibility Principle(SRP):对一个类而言，应该仅有一个引起它变化的原因。如果存在多于一个动机去改变一个类，那么这个类就具有多于一个的职责，就应该把多余的职责分离出去，再去创建一些类来完成每一个职责。

举个栗子：一个人身兼数职，而这些事情相关性不大，甚至有冲突，那他就无法很好的解决这些问题职责，应该分到不同的人身上去做。

举个栗子：手机类虽然符合人们对手机的认识，但是实际上却拥有两个不同的职责：打电话、挂断电话和发短息、接收短信，因此引起它变化的原因就是多个，是比较脆弱的设计，应该将两种行为分离。

单一职责是实现高内聚低耦合的最好方法，没有之一！！！

### 里氏替换原则

Liskov Substitution Principle（LSP）:子类可以扩展父类的功能，但是不能改变父类原有的功能。

再第一条原则开发粉笔原则种，主张“抽象”和“多态”。维持设计的封装性“抽象”是语言提供的功能，“多态”由继承语意实现。因此如何去度量继承关系种的质量？

答案是：继承必须明确确保超类（父类）所拥有的性质再子类种仍然成立。

在面向对象的思想种，一个对象就是一组状态和一系列行为的组合体。状态是对象的外在特性。LSP表述的就是在统一继承体系中的队形应该具有共同的行为特征。

举个栗子：父类也就是对象鸟有两个行为也就是方法：eat()和fly()，在子类chicken中这连个行为也应该成立，但是现实中chicken是不能非的，因此chicken中的fly()方法覆盖了父类中的方法，违反了VSP。

### 依赖倒置原则

Dependence Inversion Principle（DIP）：是一个类与类之间的调用股则。这里的依赖就是代码中的耦合。高层模块不应该依赖底层模块，二者都应该依赖其抽象了；抽象不依赖细节；细节应该依赖抽象。接口编程。

主要的思想就是：如果一个类中的一个成员或者参数成为一个具体的类型，那么这个类就依赖这个具体类型。如果在一个继承结构中，上层类中的一个成员或者参数为一个下层类型，那么就是这个继承结构高层依赖底层，就要尽量面向抽象或者接口编程。

举个栗子：存在一个Driver类，成员为一个Car对象，还有一个driver方法，Car对象中由两个方法start()与stop()。显然Driver依赖Car，也就是说Driver类调用了Car类中的方法。但是当增加Drvier类对于Bus类的支持时（司机有需要开公交车），就必须再改Driver中的代码，就破坏了开放封闭原则。根本原因在于高层的Driver类与底层的Car类紧紧的耦合再一起的。

解决方法之一就是：对于Car类和Bus类进行抽象，引入抽象类Automoble。而Car和Bus则是对Automobile的泛化。记过这样的改造发现，原本的高层依赖底层，变成了高层与底层同时依赖抽象。这就是依赖倒置原则的本质。

### 接口隔离原则

接口隔离原则（Interface Segregation Principle）：用于恰当的划分角色和接口，具有两种含义：用户不应该依赖它不需要的接口；类间的依赖关系应该建立在最小的接口上。

将这两个定义概括为一句话：简历单一接口，代替庞大臃肿的接口。通俗来说就是:接口尽量细化，同时保证接口中的方法尽量的少。一个接口中包含太多的行为时，会导致它们与客户端饿不正常依赖关系，要做的就是分离端口，从而实现解耦。

回到上述的单一职责原则，要求行为分离接口细化，感觉有些相同。但实际上，单一职责要求类与接口的职责单一，注意的是职责，没有要求接口尽量的少。

在接口隔离原则中，要求尽量使用多个专门的接口。专门的接口也就是提供给多个模块的接口。提供给几个模块就应该有几个接口，所有的模块都可以访问。

但是接口的设计是有限度的。接口的设计粒度越小，系统越灵活，这是事实，但是接口太多这也就是的结构复杂，维护难度大。因此实际中怎样把握就靠开发的经验和常识了。

### 迪米特原则

Law of Demeter(最小知识原则)：一个对象应该对其他对象有最少的了解。通俗来说就是，一个类对自己需要耦合或者调用的类知道的最少，你类内部怎么复杂，我不管，那是你的事，我只知道你有那么多公用的方法，我能调用。

迪米特原则不希望类与类之间建立直接的接触。如果真的需要有联系，那么就通过它们的友元类来传达。

举个栗子：你需要买房子，现在存在三座合适的楼盘A、B、C,但是你不必直接去楼盘买楼，而是在售楼处去了解情况，这样就减少了你（购房者）与楼盘两个类之间的耦合。

但是应用迪米特原则很有可能会造成一个后果：系统会存在大量的中介类，这些类（如上面的售楼处类）之所以存在是为了传递类之间的相互调用关系，这就一定程度上增加了系统的复杂度。

迪米特原则核心观念就是；类间解耦，弱耦合。

## 三大类型

### 创建型模式

说明：**提供创建对象的机制，能够提升已有代码的灵活性和可复用性。**

| 序号 | 类型     | 业务场景                                            | 实现要点                                                     |
| ---- | -------- | --------------------------------------------------- | ------------------------------------------------------------ |
| 1    | 工厂方法 | 多种类型商品不同接口，统一发奖服务搭建              | 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行 |
| 2    | 抽象工厂 | 替换Redis双集群升级，代理类抽象场景                 | 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 |
| 3    | 建造者   | 各项装饰物料组合套餐选配场景                        | 将一个复杂的构建与其表示相分离，是的同样的构建过程可以创建不同的表示 |
| 4    | 原型     | 上级考试多套死卷，每人一幕和答案乱序排列场景        | 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象 |
| 5    | 单例     | 7中单例模式安利，Effective Java作者推荐枚举单例模式 | 保证一个类仅用一个实例，并提供一个访问它的全局访问点         |

### 结构型模式

说明：**介绍如何将对想想和类组装成较大的结构，并同时保持结构的灵活和高效。**

| 序号 | 类型   | 业务场景                                                     | 实现要点                                                     |
| ---- | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | 适配器 | 从多个MQ消息体中，抽取指定字段值场景                         | 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能在一起工作的那些类可以一起工作 |
| 2    | 桥接   | 多支付渠道（微信、支付宝）与多支付模式（刷脸、指纹）场景     | 将抽象部分与实现部分分离，使它们都可以独立的变化             |
| 3    | 组合   | 营销差异化人群发卷，决策树引擎搭建场景                       | 将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性 |
| 4    | 装饰   | SSO单点登录功能扩展，增加拦截用户访问范围场景                | 动态地给一个对象添加一些额外地职责。就增加功能来说，装饰器模式相比生成地子类更加灵活 |
| 5    | 外观   | 基于SpringBot开发门面模式中间件，统一控制接口白名单场景      | 为子系统中地一组接口提供一个一致地界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用 |
| 6    | 享元   | 基于Redis秒杀，提供活动与库存信息查询场景                    | 运用共享技术有效地支持大量细粒度地对象                       |
| 7    | 代理   | 模拟mybatis-spring中定义DAO接口，使用代理类方法操作数据库原理实现场景 | 为其他对象提供一种代理以控制对这个对象地访问                 |

### 行为模式

说明：**负责对象间的高效沟通和职责委派。**

| 序号 | 类型     | 业务场景                                                     | 实现要点                                                     |
| ---- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | 责任链   | 模拟618电商大促期间，项目上线流程多级负责人审批场景          | 避免请求发送者和接收者耦合在一起，让多个对象都有可能接收请求，这些对象连接成一条链，并且沿着这条链传递请求，知道由对象处理它为止 |
| 2    | 命令     | 模拟高档餐厅八大菜系，小儿点单厨师烹饪场景                   | 将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化 |
| 3    | 迭代器   | 模拟公司组织架构树结构关系，深度遍历人员信息输出场景         | 提供一种方法顺序访问一个聚合对象中各个元素，而又无需暴露该对象的内部表示 |
| 4    | 中介者   | 按照Mybatis原理手写ORM框架，用JDBC方式操作数据库增加中介者场景 | 用一个中介者对象来封装一系列的对象交互，中介者使隔对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间地交互 |
| 5    | 备忘录   | 模拟互联网系统上线过程中，配置文件回滚场景                   | 在不破坏封装性地前提下，捕获一个对象地内部状态，并在该对象之外保存这个状态 |
| 6    | 观察者   | 模拟类似小客车指标摇号过程，监听消息通过之用户中签场景       | 定义对象间地一种一对多地依赖关系，当一个对象地状态发生改变时，所有依赖于它地对象都得到通知并被自动更新 |
| 7    | 状态     | 模拟系统营销活动，状态流程审核发布上线场景                   | 允许对象在内部状态发生改变时它地行为，对象看起来好像修改了它的类 |
| 8    | 策略     | 模拟多种营销类型优惠卷，折扣金额计算策略场景                 | 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换 |
| 9    | 模板方法 | 模拟爬虫各类电商商品，生成营销推广海报场景                   | 定义一个操作中的算法的股价，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤 |
| 10   | 访问者   | 模拟家长与校长，对学生和老师的不同视角信息的访问             | 主要讲数据结构与数据操作分离                                 |

